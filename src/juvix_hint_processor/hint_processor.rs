use cairo_vm::any_box;
use cairo_vm::hint_processor::hint_processor_definition::HintReference;
use cairo_vm::types::relocatable::Relocatable;
use cairo_vm::vm::runners::cairo_runner::ResourceTracker;
use cairo_vm::vm::runners::cairo_runner::RunResources;
use cairo_vm::Felt252;
use cairo_vm::{
    hint_processor::hint_processor_definition::HintProcessorLogic,
    types::exec_scope::ExecutionScopes,
    vm::errors::vm_errors::VirtualMachineError,
    vm::{errors::hint_errors::HintError, vm_core::VirtualMachine},
};
use std::any::Any;
use std::collections::HashMap;

use super::hint::Hint;

/// Execution scope for constant memory allocation.
struct MemoryExecScope {
    /// The first free address in the segment.
    next_address: Relocatable,
}

pub struct JuvixHintProcessor {
    hints: HashMap<usize, Vec<Hint>>,
    run_resources: RunResources,
}

impl JuvixHintProcessor {
    pub fn new(hints: &[(usize, Vec<Hint>)], run_resources: RunResources) -> Self {
        Self {
            hints: hints.iter().cloned().collect(),
            run_resources,
        }
    }
    // Runs a single Hint
    pub fn execute(
        &self,
        vm: &mut VirtualMachine,
        exec_scopes: &mut ExecutionScopes,
        hint: &Hint,
    ) -> Result<(), HintError> {
        match hint {
            Hint::Alloc(size) => self.alloc_constant_size(vm, exec_scopes, *size),

            hint => Err(HintError::UnknownHint(
                format!("{:?}", hint).into_boxed_str(),
            )),
        }
    }

    fn alloc_constant_size(
        &self,
        vm: &mut VirtualMachine,
        exec_scopes: &mut ExecutionScopes,
        size: usize,
    ) -> Result<(), HintError> {
        let memory_exec_scope =
            match exec_scopes.get_mut_ref::<MemoryExecScope>("memory_exec_scope") {
                Ok(memory_exec_scope) => memory_exec_scope,
                Err(_) => {
                    exec_scopes.assign_or_update_variable(
                        "memory_exec_scope",
                        Box::new(MemoryExecScope {
                            next_address: vm.add_memory_segment(),
                        }),
                    );
                    exec_scopes.get_mut_ref::<MemoryExecScope>("memory_exec_scope")?
                }
            };

        vm.insert_value(vm.get_ap(), memory_exec_scope.next_address)?;

        memory_exec_scope.next_address.offset += size;
        Ok(())
    }
}

impl HintProcessorLogic for JuvixHintProcessor {
    // Ignores all data except for the code that should contain
    fn compile_hint(
        &self,
        //Block of hint code as String
        hint_code: &str,
        //Ap Tracking Data corresponding to the Hint
        _ap_tracking_data: &cairo_vm::serde::deserialize_program::ApTracking,
        //Map from variable name to reference id number
        //(may contain other variables aside from those used by the hint)
        _reference_ids: &HashMap<String, usize>,
        //List of all references (key corresponds to element of the previous dictionary)
        _references: &[HintReference],
    ) -> Result<Box<dyn Any>, VirtualMachineError> {
        let data = hint_code.parse().ok().and_then(|x: usize| self.hints.get(&x).cloned())
        .ok_or_else(|| VirtualMachineError::CompileHintFail(
            format!("No hint found for pc {hint_code}. Cairo1HintProccesor can only be used when running CasmContractClass").into_boxed_str()
    ))?;
        Ok(any_box!(data))
    }

    // Executes all the hints for a given pc
    fn execute_hint(
        &mut self,
        //Proxy to VM, contains refrences to necessary data
        //+ MemoryProxy, which provides the necessary methods to manipulate memory
        vm: &mut VirtualMachine,
        //Proxy to ExecutionScopes, provides the necessary methods to manipulate the scopes and
        //access current scope variables
        exec_scopes: &mut ExecutionScopes,
        //Data structure that can be downcasted to the structure generated by compile_hint
        hint_data: &Box<dyn Any>,
        //Constant values extracted from the program specification.
        _constants: &HashMap<String, Felt252>,
    ) -> Result<(), HintError> {
        let hints: &Vec<Hint> = hint_data.downcast_ref().ok_or(HintError::WrongHintData)?;
        for hint in hints {
            self.execute(vm, exec_scopes, hint)?;
        }
        Ok(())
    }
}

impl ResourceTracker for JuvixHintProcessor {
    fn consumed(&self) -> bool {
        self.run_resources.consumed()
    }

    fn consume_step(&mut self) {
        self.run_resources.consume_step()
    }

    fn get_n_steps(&self) -> Option<usize> {
        self.run_resources.get_n_steps()
    }

    fn run_resources(&self) -> &RunResources {
        &self.run_resources
    }
}
